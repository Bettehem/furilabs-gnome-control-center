From 8489e800b478f2093056de0f0f5a1c0c0c063896 Mon Sep 17 00:00:00 2001
From: Hui Wang <hui.wang@canonical.com>
Date: Mon, 2 Dec 2019 13:55:28 +0800
Subject: [PATCH 1/2] mixer-control: consolidate port finding and setting
 with/without ucm

Recently Intel added a new audio driver in the Linux kernel, it is
called sof driver. This driver is needed on the laptops which
connect the digital mic to the PCH instead of the codec. To make the
sof driver work with pulseaudio, the ucm is mandatory.

With the ucm, the multi-function audio jack has different port names
in the pulseaudio from the one without ucm, these are the port names
with the ucm:
[In] Mic1: Digital Microphone
[In] Mic2: Headphones Stereo Microphone
[In] Headset: Headset Mono Microphone
[Out] Headphones: Headphones
[Out] Speaker: Speaker

To make the audio device selection work on the machines using the ucm,
the pulseaudio introduce a change to add 2 new memebers in the device
port structure from the PA_PROTOCOL_VERSION=34, with these 2 members'
help, we could consolidate the port finding and setting for both with
ucm and without ucm.

And this patch maintains the backward compatibility with the
PA_PROTOCOL_VERSION<=33,
---
 subprojects/gvc/gvc-mixer-control.c | 120 +++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 114 insertions(+), 6 deletions(-)

diff --git a/subprojects/gvc/gvc-mixer-control.c b/subprojects/gvc/gvc-mixer-control.c
index 21fc233..1c0fc75 100644
--- a/subprojects/gvc/gvc-mixer-control.c
+++ b/subprojects/gvc/gvc-mixer-control.c
@@ -104,6 +104,11 @@ struct GvcMixerControlPrivate
         gboolean has_headsetmic;
         gboolean has_headphonemic;
         gboolean headset_plugged_in;
+        char *headphones_name;
+        char *headsetmic_name;
+        char *headphonemic_name;
+        char *internalspk_name;
+        char *internalmic_name;
 #endif /* HAVE_ALSA */
 
         GvcMixerControlState state;
@@ -2171,6 +2176,18 @@ source_info_cb (pa_context           *c,
 
         s = data->port_name_to_set;
 
+        for (j = 0; j < i->n_ports; j++)
+                if (strcmp (i->ports[j]->name, s) == 0) {
+                        o = pa_context_set_default_source (c,
+                                                           i->name,
+                                                           NULL,
+                                                           NULL);
+                        if (o == NULL) {
+                                g_warning ("pa_context_set_default_source() failed");
+                                return;
+                        }
+                }
+
         if (i->active_port && strcmp (i->active_port->name, s) == 0)
                 return;
 
@@ -2215,6 +2232,7 @@ gvc_mixer_control_set_headset_port (GvcMixerControl      *control,
         g_return_if_fail (GVC_IS_MIXER_CONTROL (control));
 
 #ifdef HAVE_ALSA
+#if (PA_PROTOCOL_VERSION <= 33)
         switch (choice) {
         case GVC_HEADSET_PORT_CHOICE_HEADPHONES:
                 gvc_mixer_control_set_port_status_for_headset (control, id, "analog-output-headphones", TRUE);
@@ -2231,6 +2249,30 @@ gvc_mixer_control_set_headset_port (GvcMixerControl      *control,
         default:
                 g_assert_not_reached ();
         }
+#else
+        switch (choice) {
+        case GVC_HEADSET_PORT_CHOICE_HEADPHONES:
+                if (control->priv->headphones_name)
+                        gvc_mixer_control_set_port_status_for_headset (control, id, control->priv->headphones_name, TRUE);
+                if (control->priv->internalmic_name)
+                        gvc_mixer_control_set_port_status_for_headset (control, id, control->priv->internalmic_name, FALSE);
+                break;
+        case GVC_HEADSET_PORT_CHOICE_HEADSET:
+                if (control->priv->headphones_name)
+                        gvc_mixer_control_set_port_status_for_headset (control, id, control->priv->headphones_name, TRUE);
+                if (control->priv->headsetmic_name)
+                        gvc_mixer_control_set_port_status_for_headset (control, id, control->priv->headsetmic_name, FALSE);
+                break;
+        case GVC_HEADSET_PORT_CHOICE_MIC:
+                if (control->priv->internalspk_name)
+                        gvc_mixer_control_set_port_status_for_headset (control, id, control->priv->internalspk_name, TRUE);
+                if (control->priv->headphonemic_name)
+                        gvc_mixer_control_set_port_status_for_headset (control, id, control->priv->headphonemic_name, FALSE);
+                break;
+        default:
+                g_assert_not_reached ();
+        }
+#endif
 #else
         g_warning ("BUG: libgnome-volume-control compiled without ALSA support");
 #endif /* HAVE_ALSA */
@@ -2241,16 +2283,24 @@ typedef struct {
         const pa_card_port_info *headphones;
         const pa_card_port_info *headsetmic;
         const pa_card_port_info *headphonemic;
+        const pa_card_port_info *internalmic;
+        const pa_card_port_info *internalspk;
 } headset_ports;
 
 /*
    TODO: Check if we still need this with the changed PA port names
 
-   In PulseAudio ports will show up with the following names:
+   In PulseAudio without ucm, ports will show up with the following names:
    Headphones - analog-output-headphones
    Headset mic - analog-input-headset-mic (was: analog-input-microphone-headset)
    Jack in mic-in mode - analog-input-headphone-mic (was: analog-input-microphone)
 
+   In PulseAudio with ucm, the ports name depends on the ucm, with the current
+   ucm2, the ports will show up with the following names:
+   Headphones - [Out] Headphone
+   Headset mic - [In] Headset
+   Jack in mic-in mode - [In] Mic2
+
    However, since regular mics also show up as analog-input-microphone,
    we need to check for certain controls on alsa mixer level too, to know
    if we deal with a separate mic jack, or a multi-function jack with a
@@ -2265,6 +2315,11 @@ typedef struct {
    Headset Mic Jack - indicates headset jack where hardware can distinguish
      between headphones and headsets. There is no use popping up a dialog in
      this case, unless we already need to do this for the mic-in mode.
+
+   From the PA_PROCOTOL_VERSION=34, The device_port structure adds 2 members
+   available_group and type, with the help of these 2 members, we could
+   consolidate the port checking and port setting for non-ucm and with-ucm
+   cases.
 */
 
 static headset_ports *
@@ -2277,17 +2332,36 @@ get_headset_ports (const pa_card_info *c)
 
         for (i = 0; i < c->n_ports; i++) {
                 pa_card_port_info *p = c->ports[i];
-
+#if (PA_PROTOCOL_VERSION <= 33)
                 if (strcmp (p->name, "analog-output-headphones") == 0)
                         h->headphones = p;
                 else if (strcmp (p->name, "analog-input-headset-mic") == 0)
                         h->headsetmic = p;
                 else if (strcmp(p->name, "analog-input-headphone-mic") == 0)
                         h->headphonemic = p;
+#else
+                if (p->available_group && strcmp(p->available_group, "Headphone Mic") == 0) {
+                        if (p->type == PA_DEVICE_PORT_TYPE_HEADPHONES)
+                                h->headphones = p;
+                        else if (p->type == PA_DEVICE_PORT_TYPE_HEADSET)
+                                h->headsetmic = p;
+                        else if (p->type == PA_DEVICE_PORT_TYPE_MIC)
+                                h->headphonemic = p;
+                } else if (p->type == PA_DEVICE_PORT_TYPE_SPEAKER) {
+                        if (strcmp (p->name, "analog-output-speaker") == 0 ||
+                            strcmp (p->name, "[Out] Speaker") == 0 )
+                                h->internalspk = p;
+                } else if (p->type == PA_DEVICE_PORT_TYPE_MIC) {
+                        if (strcmp (p->name, "analog-input-internal-mic") == 0 ||
+                            strcmp (p->name, "[In] Mic1") == 0 )
+                                h->internalmic = p;
+                }
+#endif
         }
         return h;
 }
 
+#if (PA_PROTOCOL_VERSION <= 33)
 static gboolean
 verify_alsa_card (int       cardindex,
                   gboolean *headsetmic,
@@ -2340,6 +2414,32 @@ verify_alsa_card (int       cardindex,
         snd_hctl_close (hctl);
         return *headsetmic || *headphonemic;
 }
+#endif
+
+static void
+free_priv_port_names(GvcMixerControl    *control)
+{
+        if (control->priv->headphones_name != NULL) {
+                g_free (control->priv->headphones_name);
+                control->priv->headphones_name = NULL;
+        }
+        if (control->priv->headsetmic_name != NULL) {
+                g_free (control->priv->headsetmic_name);
+                control->priv->headsetmic_name = NULL;
+        }
+        if (control->priv->headphonemic_name != NULL) {
+                g_free (control->priv->headphonemic_name);
+                control->priv->headphonemic_name = NULL;
+        }
+        if (control->priv->internalspk_name != NULL) {
+                g_free (control->priv->internalspk_name);
+                control->priv->internalspk_name = NULL;
+        }
+        if (control->priv->internalmic_name != NULL) {
+                g_free (control->priv->internalmic_name);
+                control->priv->internalmic_name = NULL;
+        }
+}
 
 static void
 check_audio_device_selection_needed (GvcMixerControl    *control,
@@ -2360,7 +2460,7 @@ check_audio_device_selection_needed (GvcMixerControl    *control,
 
         if (control->priv->headset_card != (int) info->index) {
                 int cardindex;
-                gboolean hsmic, hpmic;
+                gboolean hsmic = TRUE, hpmic = TRUE;
                 const char *s;
 
                 s = pa_proplist_gets (info->proplist, "alsa.card");
@@ -2371,9 +2471,10 @@ check_audio_device_selection_needed (GvcMixerControl    *control,
                 if (cardindex == 0 && strcmp(s, "0") != 0)
                         goto out;
 
+#if (PA_PROTOCOL_VERSION <= 33)
                 if (!verify_alsa_card(cardindex, &hsmic, &hpmic))
                         goto out;
-
+#endif
                 control->priv->headset_card = info->index;
                 control->priv->has_headsetmic = hsmic && h->headsetmic;
                 control->priv->has_headphonemic = hpmic && h->headphonemic;
@@ -2383,6 +2484,12 @@ check_audio_device_selection_needed (GvcMixerControl    *control,
         }
 
         control->priv->headset_plugged_in = h->headphones->available != PA_PORT_AVAILABLE_NO;
+        free_priv_port_names(control);
+        control->priv->headphones_name = h->headphones ? g_strdup(h->headphones->name) : NULL;
+        control->priv->headsetmic_name = h->headsetmic ? g_strdup(h->headsetmic->name) : NULL;
+        control->priv->headphonemic_name = h->headphonemic ? g_strdup(h->headphonemic->name) : NULL;
+        control->priv->internalspk_name = h->internalspk ? g_strdup(h->internalspk->name) : NULL;
+        control->priv->internalmic_name = h->internalmic ? g_strdup(h->internalmic->name) : NULL;
 
         if (!start_dialog &&
             !stop_dialog)
@@ -3499,7 +3606,9 @@ gvc_mixer_control_dispose (GObject *object)
                 g_hash_table_destroy (control->priv->ui_inputs);
                 control->priv->ui_inputs = NULL;
         }
-
+#ifdef HAVE_ALSA
+        free_priv_port_names(control);
+#endif
         G_OBJECT_CLASS (gvc_mixer_control_parent_class)->dispose (object);
 }
 
@@ -3735,7 +3844,6 @@ static void
 gvc_mixer_control_finalize (GObject *object)
 {
         GvcMixerControl *mixer_control;
-
         g_return_if_fail (object != NULL);
         g_return_if_fail (GVC_IS_MIXER_CONTROL (object));
 
-- 
GitLab


From ec088a35a44bfd66be13c7229a5d1ab936d3beff Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Tue, 2 Jun 2020 12:20:45 +0200
Subject: [PATCH 2/2] mixer-control: do not use port name string to select the
 headset ports

It is a bad idea to use the variable port name to check the port
type. Use only the new port type and availability group string
for the decision.

Also, select the ports by priority, if there multiple ports
with the similar type.
---
 subprojects/gvc/gvc-mixer-control.c | 52 +++++++++++++++++++++++++++------------------
 1 file changed, 31 insertions(+), 21 deletions(-)

diff --git a/subprojects/gvc/gvc-mixer-control.c b/subprojects/gvc/gvc-mixer-control.c
index 1c0fc75..3c33d4d 100644
--- a/subprojects/gvc/gvc-mixer-control.c
+++ b/subprojects/gvc/gvc-mixer-control.c
@@ -2288,19 +2288,11 @@ typedef struct {
 } headset_ports;
 
 /*
-   TODO: Check if we still need this with the changed PA port names
-
    In PulseAudio without ucm, ports will show up with the following names:
    Headphones - analog-output-headphones
    Headset mic - analog-input-headset-mic (was: analog-input-microphone-headset)
    Jack in mic-in mode - analog-input-headphone-mic (was: analog-input-microphone)
 
-   In PulseAudio with ucm, the ports name depends on the ucm, with the current
-   ucm2, the ports will show up with the following names:
-   Headphones - [Out] Headphone
-   Headset mic - [In] Headset
-   Jack in mic-in mode - [In] Mic2
-
    However, since regular mics also show up as analog-input-microphone,
    we need to check for certain controls on alsa mixer level too, to know
    if we deal with a separate mic jack, or a multi-function jack with a
@@ -2322,6 +2314,12 @@ typedef struct {
    cases.
 */
 
+#define HEADSET_PORT_SET(dst, src) \
+        do { \
+                if (!(dst) || (dst)->priority < (src)->priority) \
+                        dst = src; \
+        } while (0)
+
 static headset_ports *
 get_headset_ports (const pa_card_info *c)
 {
@@ -2340,24 +2338,36 @@ get_headset_ports (const pa_card_info *c)
                 else if (strcmp(p->name, "analog-input-headphone-mic") == 0)
                         h->headphonemic = p;
 #else
-                if (p->available_group && strcmp(p->available_group, "Headphone Mic") == 0) {
-                        if (p->type == PA_DEVICE_PORT_TYPE_HEADPHONES)
-                                h->headphones = p;
-                        else if (p->type == PA_DEVICE_PORT_TYPE_HEADSET)
-                                h->headsetmic = p;
-                        else if (p->type == PA_DEVICE_PORT_TYPE_MIC)
-                                h->headphonemic = p;
+                /* in the first loop, set only headphones */
+                /* the microphone ports are assigned in the second loop */
+                if (p->type == PA_DEVICE_PORT_TYPE_HEADPHONES) {
+                        if (p->available_group)
+                                HEADSET_PORT_SET(h->headphones, p);
                 } else if (p->type == PA_DEVICE_PORT_TYPE_SPEAKER) {
-                        if (strcmp (p->name, "analog-output-speaker") == 0 ||
-                            strcmp (p->name, "[Out] Speaker") == 0 )
-                                h->internalspk = p;
+                        HEADSET_PORT_SET(h->internalspk, p);
                 } else if (p->type == PA_DEVICE_PORT_TYPE_MIC) {
-                        if (strcmp (p->name, "analog-input-internal-mic") == 0 ||
-                            strcmp (p->name, "[In] Mic1") == 0 )
-                                h->internalmic = p;
+                        if (!p->available_group)
+                                HEADSET_PORT_SET(h->internalmic, p);
                 }
 #endif
         }
+
+#if (PA_PROTOCOL_VERSION > 33)
+        if (h->headphones) {
+                for (i = 0; i < c->n_ports; i++) {
+                        pa_card_port_info *p = c->ports[i];
+                        if (g_strcmp0(h->headphones->available_group, p->available_group))
+                                continue;
+                        if (p->direction != PA_DIRECTION_INPUT)
+                                continue;
+                        if (p->type == PA_DEVICE_PORT_TYPE_HEADSET)
+                                HEADSET_PORT_SET(h->headsetmic, p);
+                        else if (p->type == PA_DEVICE_PORT_TYPE_MIC)
+                                HEADSET_PORT_SET(h->headphonemic, p);
+                }
+        }
+#endif
+
         return h;
 }
 
